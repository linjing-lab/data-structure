**求子串位置的定位函数Index(S, T, pos)**，子串的定位操作通常称为串的**模式匹配**（其中T被称为模式串），是各种串处理系统中最重要的操作之一。
```c
int Index(SString S, SString T, int pos){
	i = pos;
	j = 1;
	while(i <= S[0] && j <= T[0]){
		if(S[i] == T[j]){++i; ++j;}
		else {i = i - j + 2; j = 1;}	/* 指针i的回溯操作 */
	}
	if(j > T[0]) return i-T[0];
	else return 0;
}
```
利用计数指针i和j指示主串S和模式串T中当前正待比较的字符位置。 算法的基本思想是：从主串S的第pos个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符，否则从主串的下一个字符起再重新和模式的字符比较之。 模式T中的每个字符依次和主串S中的一个连续字符序列相等，则称**匹配成功**，函数值为和模式T中第一个字符相等的字符在主串S中的序号，否则称**匹配不成功**，函数值为零。

该算法的最坏时间复杂度为O(nm)

`KMP`算法，是D.E.Knuth与V.R.Pratt和J.H.Morris同时发现的。 此算法可以在O(n+m)的时间数量级上完成串的模式匹配操作。 每当一趟匹配过程中出现字符比较不等时，不需回溯i指针，而是利用已经得到的“部分匹配”的结构将模式向右“滑动”尽可能远的一段距离后，继续进行比较。

为了实现改进算法，当匹配过程中产生“失配”，模式串“向右滑动”可行的距离多远，换句话说，当主串第i个字符与模式中第j个字符“失配”时，主串中第i个字符应与模式中哪个字符再比较？
> 假设此时应为模式中第k个字符，k小于j，继续比较，则模式中前k-1个字符的子串必须满足下列关系式，且不可能存在k'>k，满足下列关系式：
p1 p2... pk-1 = si-k+1 si-k+2 ... si-1

而已经得到的“部分匹配”的结果是：
pj-k+1 pj-k+2 ... pj-1 = si-k+1 si-k+2 ... si-1

得到下列等式：
p1 p2 ... pk-1 = pj-k+1 pj-k+2 ... pj-1

若令next[j]=k，则next[j]表明当模式中第j个字符主串中相应字符“失配”时，在模式中需重新和主串中该字符进行比较的字符的位置。 由此引出模式串的next函数的定义：
```textile
			0
next[j] =   Max{k|1 < k < j 且 p1 p2 ... pk-1 = pj-k+1 pj-k+2 ... pj-1}
			1,	其他情况
```
由此定义可推出下列模式串的next函数值：
```textile
j        1 2 3 4 5 6 7 8
模式串    a b a a b c a c
next[j]  0 1 1 2 2 3 1 2
```
假设以指针i和j分别指示主串和模式串正待比较的字符，令i的初值为pos，j的初值为1。 若在匹配过程中s_i = p_j，则i和j分别增1，否则，i不变，而j退到next[j]的位置再比较。若相等，则指针各自增1，否则j再退到下一个next值得位置，依次类推。

KMP算法匹配过程中产生“失配”时，指针i不变，指针j退回到next[j]所指示的位置上重新进行比较，并且当指针j退至零时，指针i和指针j需同时增1。即若主串的第i个字符和模式的第1个字符不等，应从主串的第i+1个字符起重新进行匹配。
```c
int Index_KMP(SString S, SString T, int pos){
	i = pos;
	j = 1;
	while(i <= S[0] && j <= T[0]){
		if(j == 0 && S[i] == T[j]) {++i; ++j;}
		else return j = next[j];
	}
	if(j > T[0]) return i-T[0];
	else return 0;
}
```
从上述讨论可见，此函数值取决于模式串本身而和相匹配的主串无关。我们可从分析其定义出发用递推的方法求得next函数值。
由定义知：next[i]=0
设next[j]=k，这表明在模式串中存在下列关系：
```textile
p1 p2 ... pk-1 = pj-k+1 pj-k+2 ... pj-1
```
其中k为满足1小于k小于j的某个值，并且不可能存在k'大于k满足等式。 此时next[j+1]=？可能有两种情况：
(1) 若pk = pj，则表明在模式串中
```textile
p1 p2 ... pk = pj-k+1 pj-k+2 ... pj
```
并且不可能存在k'大于k满足等式，next[j+1]=k+1，即
```textile
next[j+1]=next[j]+1
```
(2) 若pk 不等于 pj，则表明在模式串中
```textile
p1 ... pk 不等于 pj-k+1 ... pj
```
此时可把求next函数值的问题看成是一个模式匹配的问题，整个模式串既是主串又是模式串，而当前在匹配的过程中，已有pj-k+1 = p1, pj-k+2=p2, ..., pj-1=pk-1，则当pj 不等于 pk时应将模式向右滑动至以模式中的第next[k]个字符和主串中的第j个字符相比较。 若next[k]=k'，且pj = pk'，则说明在主串中第j+1字符之前存在一个长度为k'（即next[k]）的最长子串，和模式串中从首字符起长度为k'的子串相等，即：
```textile
next[j+1]=k'+1
```
即：next[j+1]=next[k]+1.
同理，若pj 不等于 pk'，则将模式继续向右滑动直至将模式中第next[k']个字符和pj对齐，依次类推，直至pj和模式中某个字符匹配成功或者不存在任何k'满足等式，则：
```textile
next[j+1]=1
```
next[6]=3, p6 不等于 p3, next[3]=1, p6 不等于 p1, 而且next[1]=0, 所以next[7]=1, 而因为p7 = p1，则next[8]=2。
```c
void get_next(SString T, int &next[]){
	i = 1;
	next[1] = 0;
	j = 0;
	while(i < T[0]){
		if(j == 0 || T[i] == T[j]) {++i; ++j; next[i]=j;}
		else j = next[j];
	}
}
```
> 模式'aaaab'在和主串'aaabaaaab'匹配时，
```c
void get_nextval(SString T, int &next[]){
	i=1;
	nextval[1] = 0;
	j = 0;
	while(i < T[0]){
		if(j == 0 || T[i] == T[j]){
			++i; ++j;
			if(T[i] != T[j]) nextval[i]=j;
			else nextval[i]=nextval[j];
		}else j = nextval[j];
	}
}
```