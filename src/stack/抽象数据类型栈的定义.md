`栈`是操作受限的线性表，可以称为限定性的数据结构。

**栈**是限定仅在表尾进行插入或删除操作的线性表。因此，对栈来说，表尾端有特殊含义，称为**栈顶（top）**，相应地，表头端称为栈底。不含元素的空表称为空栈。

假设栈S=(a_1, a_2, ..., a_n)，则称a_1为栈底元素，a_n为栈顶元素。 栈中元素按a_1, a_2, ..., a_n的次序进栈，退栈的第一个元素应为栈顶元素。因此栈遵循**后进先出（Last In First Out）**的线性表（简称**LIFO**结构），它的整个特点可以形象地表示为铁路调度站。

下面给出栈的抽象数据类型的定义：
```textile
ADT Stack{
	数据对象：D={a_i|a_i \in ElemSet, i=1, 2, ..., n >= 0}
	数据关系：R_1 = {<a_{i-1}, a_i>|a_{i-1}, a_i \in D, i=2, ..., n}
			约定a_n端为栈顶，a_1端为栈底。
	基本操作：
		InitStack(&S);
	操作结果：构造一个空栈S.

		DestroyStack(&S);
	初始条件：栈S已存在。
	操作结果：栈S被销毁。

		ClearStack(&S);
	初始条件：栈S已存在。
	操作结果：将S清为空栈。

		StackEmpty(S);
	初始条件：栈S已存在。
	操作结果：若栈S为空栈，则返回TRUE，否则FALSE。

		StackLength(S);
	初始条件：栈S已存在。
	操作结果：返回S的元素的个数，即栈的长度。

		GetTop(S, &e);
	初始条件：栈S已存在且非空。
	操作结果：用e返回S的栈顶元素。

		Push(&S, e);
	初始条件：栈S已存在。
	操作结果：插入元素e为新的栈顶元素。

		Pop(&S, &e);
	初始条件：栈S已存在且非空。
	操作结果：删除S的栈顶元素，并用e返回其值。

		StackTraverse(S, visit());
	初始条件：栈S已存在且非空。
	操作结果：从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦visit()失败，则操作失效。
}
```
插入元素的操作为入栈，删除栈顶元素的操作称为出栈。

`顺序栈`，即栈的顺序存储结构是，利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，同时附设指针top指示栈顶元素在顺序栈中的位置。

以top=0表示空栈，由于栈的使用过程中所需最大空间的大小很难估计，因此，一般来说，在初始化设空栈时不应限定栈的最大容量。一个较合理的做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再逐段扩大。 为此，可以设定两个常量：STACK_INIT_SIZE（存储空间初始分配量）和STACK_INCREMENT（存储空间分配增量），并以下述类型说明作为顺序栈的定义：
```c
typedef struct{
	SElemType *base;
	SElemType *top;
	int stack_size;
}SqStack;
```
其中，stack_size指示栈的当前可使用的最大容量。 栈的初始化操作为： 按设定的初始分配量进行第一次存储分配， base可称为栈底指针，在顺序栈中，它始终指向栈底的位置， 若base的值为NULL，则表明栈结构不存在。

称top为栈顶指针，其初值指向栈底，即top=base可作栈空的标记，每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1，因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上。 