现今我们使用的计算机的硬件结构主要是反映数值计算的需要的，因此，在处理字符串数据时比处理整数和浮点数要复杂得多。

**串（String）**是由零个或多个字符组成的有限序列。一般记为：
```textile
s='a1a2...an'
```
其中，s是串的名，用单引号括起来的字符序列是串的值；a_i可以是字母、数字或其它字符；串中字符的数目n称为串的**长度**。零个字符的串称为**空串**（Null string），它的长度为零。

串中任意个连续的字符组成的子序列称为该串的**子串**。包含子串的串相应地称为**主串**。通常称字符在序列中的序号为该字符在串中的**位置**。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。

称两个串是**相等**的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。

串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。

在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其它字符中间。由一个或多个空格组成的串' '称为**空格串（blank string）**。它的长度为串中空格字符的个数。

串的逻辑结构和线性表极为相似，区别仅仅在于串的数据对象约束为字符集。在串的基本操作中，通常以“串的整体”作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串。

```textile
//容易
ADT 串（string)
Data
       串中元素仅由一个字符组成，相邻元素具有前驱和后继关系
Operation
      StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。

      StrCopy(T,S):串S存在，由串S复制得串T。

      ClearString(S):串S存在，将串清空。

      StringEmpty(S)：若串为空，则返回true，否则返回false。

      StrLength(S):返回S的元素个数，即串S的长度。

      StrCompare(S,T):若S>T，返回>0,S=T,返回=0，S<T，返回<0.

      Concat(T,S1,S2):用T返回由S1和S2联接而成的新串。

      SubString(Sub,S,pos,len):串S存在，1<=pos<=Strlength(S),且0<=len<=Strlength(S)-pos+1.用Sub返回串S的第pos个字符起长度为len的子串。  

      Index（S,T,pos):串S和T存在，T是非空串，1<=pos<=Strlength(S).若主串S中存在和串T值相同的字串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0

      Replace(S,T,V):串S，T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。

      StrInsert(S,pos,T):串S和T存在，1<=pos<=Strlength(S)+1.在串S的第pos个字符之前插入串T。

      SteDelete(S,pos,len):串S存在，1<=pos<=StrLength(s)-len+1.从串S中删除第pos个字符起长度为len的子串。
```
最小操作子集：串赋值（StrAssign、StrCompare、StrLength、Concat、SubString）

利用判等、求串长和求子串等操作实现定位函数Index(S, T, pos)。算法的基本思想为：在主串S中取从第i个字符起、长度和串T相等的子串和串T比较，若相等，则求得函数值为i，否则i值增1直至串S不存在和串T相等的子串为止。
```c
int Index(String S, String T, int pos){
	if(pos > 0){
		n = StrLength(S);
		m = StrLength(T);
		i = pos;
		while(i <= n - m + 1){
			SubString(sub, S, i, m);
			if(StrCompare(sub, T)!=0) ++i;
			else return i;
		}
	}
	return 0; /* 不存在与T相等的子串 */
}
```
**定长顺序存储表示**，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照予以定义的大小，为每个定义的串变量分配一个固定长度的存储区。
1. 串联接Concat(&T, S1, S2)
假设S1、S2和T都是SString型的变量，且串T是由串S1联结S2得到的，即串T的值的前一段和串S1的值相等，串T的值的后一段和串S2的值相等，则只要进行相应的“串值复制”操作即可，只是需按前述约定，对超长部分实施“截断”操作。基于串S1和S2长度的不同情况，串T值得产生可能有如下三种情况：
1）S1[0] + S2[0] <= MAXSTRLEN
2）S1[0] < MAXSTRLEN；S1[0] + S2[0] > MAXSTRLEN
3）S1[0] = MAXSTRLEN

2. 求子串SubString(&Sub, S, pos, len)
求子串得过程即为复制字符序列的过程，将串S中从第pos个字符开始长度为len的字符序列复制到串Sub中。 不存在截断的情况，但有可能产生用户给出的参数不符合操作的初始条件，当参数非法时，返回ERROR。

如何克服截尾法这个弊病，唯有不限定串长的最大长度，即动态分配串值得存储空间。

**堆分配存储表示**：仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间是在程序执行过程中动态分配而得。 由C语言的动态分配函数malloc()和free()来管理。 利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址。

```c
typedef struct{
	char *ch;
	int length;
}HString;
``` 
StrCopy(&T, S)的实现算法是，若串T已存在，则先释放串T所占空间，当串S不为空时，首先为串T分配大小和串S长度相等的存储空间，然后将串S的值复制到串T中。

StrInsert(&S, pos, T)的实现算法是：为串S重新分配大小等于串S和串T长度之和的存储空间，然后进行串值复制。
```c
Status StrInsert(HString &S, int pos, HString T){
	if(pos < 1 || pos > S.length + 1) return ERROR;
	if(T.length){
		if(!(S.ch = (char *)realloc(S.ch, (S.length + T.length) * sizeof(char)))) exit(OVERFLOW);
		for(i = S.length - 1; i >= pos - 1; --i) S.ch[i+T.length] = S.ch[i];
		S.ch[pos - 1]..pos+T.length-2] = T.ch[0..T.length-1];
		S.length += T.length;
	}
	return OK;
}
```
**串的块存储表示**，用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。 当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中最后一个结点不一定全被串值占满，此时通常补上"#"或其它的非串值字符（通常"#"不属于串的字符集，是一个特殊的符号）。

为了便于进行串的操作，当以链表存储串值时，除头指针外还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。
```c
#define CHUNKSIZE 80
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;
typedef struct{
	Chunk *head, *tail;	/* 串的头和尾指针 */
	int curlen;	/* 串的当前长度 */
}LString;
```
由于在一般情况下，对串进行操作时，只需要从头向尾顺序扫描即可，则对串值不必建立双向链表。 设**尾指针**的目的是为了便于进行**联结**操作，但应注意联结时需处理第一个串尾的无效字符。

在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。 串值的存储密度可定义为：
存储密度=（串值所占的存储位）/（实际分配的存储位）。显然，存储密度（如结点大小为1时），运算处理方便，然而存储占用量大。 如果在串处理过程中需进行内、外存交换的话，则会因为内外存交换操作过多而影响处理的总效率。 串的字符集的大小是一个重要因素，一般地，字符集小，则字符的机内编码就短。

串值的链式存储结构对某些串操作，如联接操作等有一定方便之处。 总的来说，不如另外两种存储结构灵活，它占用存储量大且操作复杂。