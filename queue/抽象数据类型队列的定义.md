和栈相反，**队列（Queue）**是一种先进先出的线性表，它只允许在表的一端进行插入，而在另一端删除元素。 最早进入队列的元素最早离开。 在队列中，允许插入的一端叫做**队尾（rear）**，允许删除的一端则称为**队头（front）**。 假设队列为q=(a_1, a_2, ...,a_n)，那么，a_1就是队头元素，a_n是队尾元素。 队列中的元素是按照a_1, a_2, ...,a_n的顺序进入的，退出队列也只能按照这个次序依次退出，只有在a_1, a_2, ...,a_n都离开队列之后，a_n才能对出队伍。

操作系统中的作业排队。 在允许多道程序运行的计算机系统中，同时有几个作业运行。 如果运行的结果都需要通过通道输出，那就要按请求输出的先后次序排队。 每当通道传输完毕可以接受新的输出任务时，队头的作业先从队列中退出作输出操作。

```textile
ADT Queue{
	数据对象：D={a_i|a_i \in ElemSet, i=1,2,...,n, n>=0}
	数据关系：R_1={<a_{i-1}, a_i>|a_{i-1},a_i \in D, i=2,...,n}
	基本操作：
		InitQueue(&Q);
			操作结果：构造一个空队列Q。
		DestroyQueue(&Q);
			初始条件：队列Q已存在。
			操作结果：队列Q被销毁，不再存在。
		ClearQueue(&Q);
			初始条件：队列Q已存在。
			操作结果：将Q清为空队列。
		QueueEmpty(Q);
			初始条件：队列Q已存在。
			操作结果：若Q为空队列，则返回TRUE，否则FALSE;
		QueueLength(Q);
			初始条件：队列Q已存在。
			操作结果：返回Q的元素个数，即队列的长度。
		GetHead(Q, &e);
			初始条件：Q为非空队列。
			操作结果：用e返回Q的队头元素。
		EnQueue(&Q, e);
			初始条件：队列Q已存在。
			操作结果：插入元素e为Q的新的队尾元素。
		DeQueue(&Q, &e);
			初始条件：Q为非空队列。
			操作结果：删除Q的队头元素，并用e返回其值。
		QueueTraverse(Q, visit());
			初始条件：Q已存在且非空。
			操作结果：从队头到队尾，依次对Q的每个数据元素调用函数visit()。 一旦visit()失败，则操作失败。
}
```
除了栈的队列之外，还有一种限定性数据结构是**双端队列（Deque）**。

**双端队列**是限定插入和删除操作在表的两端进行的线性表。 有输出受限的双端队列（即一个端点允许插入和删除，另一个端点只允许插入的双端队列）和输入受限的双端队列（即一个端点允许插入和删除，另一个端点只允许删除的双端队列）。

用链表表示的队列简称为**链队列**，一个链队列显然需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。 空的链队列的判决条件为头指针和尾指针均指向头结点。