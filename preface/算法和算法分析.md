算法（Algorithm)是对特定问题求解步骤的一种描述，它是指令的有序序列，其中每一个指令表示一个或多个操作：
1. 有穷性：一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性：算法中每一条指令必须有确切的含义，不会产生二义性。并且在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出。
3. 可行性：算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。
4. 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
5. 输出：一个算法有一个或多个输出。这些输出是同输入有着某些特定关系的量。

正确性：
* 程序不含语法错误
* 程序对于几组输入数据能够得出满足规格要求的结果
* 程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得到满足规格要求的结果（衡量一个程序是否合格的标准）
* 程序对于一些合法输入都能产生满足规格说明要求的结果。

可读性：
* 为了人的阅读与交流
* 便于理解与修改

健壮性：
* 当输入数据非法时，算法也能适当地作出反应或进行处理，而不会产生莫名其妙的输出结果。
* 处理错误的方法是返回一个表示错误或错误性质的值，而不是打印错误信息或异常，并中止程序的执行。

效率与低存储量需求：
* 效率指的是算法执行时间
* 存储需求量指算法执行过程中所需要的最大存储空间
* 这两者都与问题的规模有关

算法效率的度量：
1. 事后统计方法，不同的算法程序可以通过一组或者若干组相同的统计数据加以分辨优劣，但是有两个缺陷：必须先运行一句算法编制的程序，二是所得时间的统计量依赖于计算机的硬件、软件等环境因素。

2. **事前分析方法**
	a. 依据的算法选用何种策略
	b. 问题的规模，例如求100以内还是求1000以内的素数
	c. 书写程序的语言，对于同一个算法，实现语言的级别越高，执行效率越低（比如C与Python）
	d. 编译程序所产生的机器代码的质量
	e. 机器执行指令的速度

因为同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行时，效率均不同，所以使用绝对时间单位衡量算法的效率是不合适的。 如果不去管计算机硬件与软件的影响因素，可以认为一个特定算法“运行工作量”的大小，只依赖于问题的规模（通常用整数n表示），或者说它是问题规模的函数。

一个算法是有控制结构（顺序、分支和循环三种）的原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。通常我们从算法中选取一种对于所研究的问题来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。

一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度为T(n) = O(f(n))。 它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作**渐进时间复杂度**，简称时间复杂度。

被称作问题的基本操作的原操作应是其重复执行次数和算法的执行时间成正比的原操作，多数情况下它是最深层循环内的语句中的原操作，它的执行次数和包含它的语句的频度相同。
```c
{++x; s=0;}
for(i=1, i<=n; ++i) {++x; s+=x;}
for(j=1; j<=n; ++j)
	for(k=1; k<=n; ++k) {++x; s+=x;}
```
从上至下的时间复杂度分别为1，n和n^2，分别称为常量阶、线性阶和平方阶。

由于算法的时间复杂度考虑的只是对于问题规模n的增长率，则在难以精确计算基本操作执行次数（或语句频度）的情况下，只需求出它关于n的增长率或阶即可。

以冒泡排序为例，最好情况（序列从小到大排列）下的时间复杂度为O(1)，当初始序列为自大至小时，基本操作的执行次数为n(n-1)/2。

可以选择考虑所有可能输入数据集的期望值，此时的时间复杂度为算法的平均时间复杂度。 假设序列中输入数据可能出现n!种的排列情况的概率相等，则起泡排序的平均时间复杂度为O(n^2)，然后在很多情况下，各种输入数据集出现的概率难以确定。因此我们可以计算它的最坏时间复杂度，来求得算法执行时间的一个上界。

估算：若上机运行两个10x10的矩阵相乘，执行时间为12ms，则由算法的时间复杂度O(n^3)可估算两个31x31的矩阵相乘需要的时间大致为(31/10)^3 · 12ms=358ms.

一个上机执行的程序除了需要存储空间来寄存本身常用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需星系的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应同时考虑输入本身所需空间（和输入数据的表示形式有关）