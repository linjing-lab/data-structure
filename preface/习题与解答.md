# 绪论习题与解答
# 绪论习题与解答
## 4. 复数与有理数的抽象数据类型
复数：
```textile
ADT Complex{
	数据对象：D={m, n|m, n为实数}
	数据关系：R={<m, n>}
	基本操作：
		InitComplex(&C, re, im)
			操作结果：构造一个复数C，其实部和虚部分别为re和im
		DestroyComplex(&C)
			操作结果：销毁复数C
		Get(C, k, &e)
			操作结果：用e返回复数C的第k元的值
		Put(&C, k, e)
			操作结果：更改第k元的值为e
		IsAscending(C)
			操作结果：如果复数C的两个元素按升序排列，则返回1，否则返回0
		IsDescending(C)
			操作结果：如果复数C的两个元素按降序排列，则返回1，否则返回0
		Max(C, &e)
			操作结果：用e返回复数C的两个元素中值较大的一个
		Min(C, &e)
			操作结果：用e返回复数C的两个元素中值较小的一个
}ADT Complex
```
有理数：
```textile
ADT RationalNumber{
	数据对象：D={s, m|s, m为自然数，且m不为0}
	数据关系：R={<s, m>}
	基本操作：
		InitRationalNumber(&R, s, m)
			操作结果：构造一个有理数R，其分子和分母分别为s和m
		DestroyRationalNumber(&R)
			操作结果：销毁有理数R
		Get(R, k, &e)
			操作结果：用e返回有理数C的第k元的值
		Put(&R, k, e)
			操作结果：更改第k元的值为e
		IsAscending(R)
			操作结果：如果有理数R的两个元素按升序排列，则返回1，否则返回0
		IsDescending(R)
			操作结果：如果有理数R的两个元素按降序排列，则返回1，否则返回0
		Max(R, &e)
			操作结果：用e返回有理数R的两个元素中值较大的一个
		Min(R, &e)
			操作结果：用e返回有理数R的两个元素中值较小的一个
}ADT RationalNumber
```
## 6. 在程序设计中，常用下列三种不同的出错处理方式
(1) 用 exit 语句终止执行并报告错误；
(2) 以函数的返回值区别正确返回或错误返回；
(3) 设置一个整型变量的函数参数以区别正确返回或某种错误返回。
试讨论这三种方法各自的优缺点：
```textile
(1) exit 常用于异常错误处理，它可以强行中断程序的执行，返回操作系统。
(2) 以函数的返回值判断正确与否常用于子程序的测试，便于实现程序的局部控制。
(3) 用整型函数进行错误处理的优点是可以给出错误类型，便于迅速确定错误。
```
## 7. 在程序设计中，可采用下列三种方法实现输出和输入
(1) 通过 `scanf` 和 `printf` 语句；
(2) 通过函数的参数显式传递；
(3) 通过全局变量隐式传递。
试讨论这三种方法的优缺点。
```textile
(1) 用 scanf 和 printf 直接进行输入输出的好处是形象、直观，但缺点是需要对其进行格式控制，较为烦琐，如果出现错误，则会引起整个系统的崩溃。
(2) 通过函数的参数传递进行输入输出，便于实现信息的隐蔽，减少出错的可能。
(3) 通过全局变量的隐式传递进行输入输出最为方便，只需修改变量的值即可，但过多的全局变量使程
序的维护较为困难。
```
## 8. 设 n 为正整数。试确定下列各程序段中前置以记号@的语句的频度
(1):
```cpp
k = 0
for(int i=1; i<=n; i++){
	for(int j=i; j<=n; j++){
		@ k++;
	}
}
```
```textile
n+(n-1)+(n-2)+...+1=n(n+1)/2
```
(2):
```cpp
for(int i=1; i<=n; i++){
	for(int j=1; j<=i; j++){
		for(int k=1; k<=j; k++){
			@ x += delta;
		}
	}
}
```
```textile
1+(1+2(1+2+3)+...+(1+2+3+...+n)=sum[i(i+1)/2]
=1/2 * sum[i(i+1)]
=1/2 * sum[i^2 + i]
=1/2 * sum[i^2] + 1/2 sum[i]
=1/12 * n(n+1)(2n+1) + 1/4 * n(n+1)=1/12 * n(n+1)(2n+3)
```
(3):
```cpp
i=1; j=0;
while(i+j<=n){
	@ if(i>j) j++;
	else i++;
}
```
```textile
n
```
(4):
```cpp
x=n; y=0;
while(x>=(y+1)*(y+1)){
	@ y++;
}
```
```textile
\sqrt{n} 向下取整
```
(5):
```cpp
x=91; y=100;
while(y>0){
	@ if(x>100) {x-=10; y--;}
	else x++;
}
```
```textile
要看y在什么时候<=0
11+11+11+...11 共计有100个11，当y=0时退出循环
```