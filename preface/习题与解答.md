# 绪论习题与解答
## 4. 复数与有理数的抽象数据类型
复数：
```textile
ADT Complex{
	数据对象：D={m, n|m, n为实数}
	数据关系：R={<m, n>}
	基本操作：
		InitComplex(&C, re, im)
			操作结果：构造一个复数C，其实部和虚部分别为re和im
		DestroyComplex(&C)
			操作结果：销毁复数C
		Get(C, k, &e)
			操作结果：用e返回复数C的第k元的值
		Put(&C, k, e)
			操作结果：更改第k元的值为e
		IsAscending(C)
			操作结果：如果复数C的两个元素按升序排列，则返回1，否则返回0
		IsDescending(C)
			操作结果：如果复数C的两个元素按降序排列，则返回1，否则返回0
		Max(C, &e)
			操作结果：用e返回复数C的两个元素中值较大的一个
		Min(C, &e)
			操作结果：用e返回复数C的两个元素中值较小的一个
}ADT Complex
```
有理数：
```textile
ADT RationalNumber{
	数据对象：D={s, m|s, m为自然数，且m不为0}
	数据关系：R={<s, m>}
	基本操作：
		InitRationalNumber(&R, s, m)
			操作结果：构造一个有理数R，其分子和分母分别为s和m
		DestroyRationalNumber(&R)
			操作结果：销毁有理数R
		Get(R, k, &e)
			操作结果：用e返回有理数C的第k元的值
		Put(&R, k, e)
			操作结果：更改第k元的值为e
		IsAscending(R)
			操作结果：如果有理数R的两个元素按升序排列，则返回1，否则返回0
		IsDescending(R)
			操作结果：如果有理数R的两个元素按降序排列，则返回1，否则返回0
		Max(R, &e)
			操作结果：用e返回有理数R的两个元素中值较大的一个
		Min(R, &e)
			操作结果：用e返回有理数R的两个元素中值较小的一个
}ADT RationalNumber
```
## 6. 在程序设计中，常用下列三种不同的出错处理方式
(1) 用 exit 语句终止执行并报告错误；
(2) 以函数的返回值区别正确返回或错误返回；
(3) 设置一个整型变量的函数参数以区别正确返回或某种错误返回。
试讨论这三种方法各自的优缺点：
```textile
(1) exit 常用于异常错误处理，它可以强行中断程序的执行，返回操作系统。
(2) 以函数的返回值判断正确与否常用于子程序的测试，便于实现程序的局部控制。
(3) 用整型函数进行错误处理的优点是可以给出错误类型，便于迅速确定错误。
```
## 7. 在程序设计中，可采用下列三种方法实现输出和输入
(1) 通过 `scanf` 和 `printf` 语句；
(2) 通过函数的参数显式传递；
(3) 通过全局变量隐式传递。
试讨论这三种方法的优缺点。
```textile
(1) 用 scanf 和 printf 直接进行输入输出的好处是形象、直观，但缺点是需要对其进行格式控制，较为烦琐，如果出现错误，则会引起整个系统的崩溃。
(2) 通过函数的参数传递进行输入输出，便于实现信息的隐蔽，减少出错的可能。
(3) 通过全局变量的隐式传递进行输入输出最为方便，只需修改变量的值即可，但过多的全局变量使程
序的维护较为困难。
```
## 8. 设 n 为正整数。试确定下列各程序段中前置以记号@的语句的频度
(1):
```cpp
k = 0
for(int i=1; i<=n; i++){
	for(int j=i; j<=n; j++){
		@ k++;
	}
}
```
```textile
n+(n-1)+(n-2)+...+1=n(n+1)/2
```
(2):
```cpp
for(int i=1; i<=n; i++){
	for(int j=1; j<=i; j++){
		for(int k=1; k<=j; k++){
			@ x += delta;
		}
	}
}
```
```textile
1+(1+2(1+2+3)+...+(1+2+3+...+n)=sum[i(i+1)/2]
=1/2 * sum[i(i+1)]
=1/2 * sum[i^2 + i]
=1/2 * sum[i^2] + 1/2 sum[i]
=1/12 * n(n+1)(2n+1) + 1/4 * n(n+1)=1/12 * n(n+1)(2n+3)
```
(3):
```cpp
i=1; j=0;
while(i+j<=n){
	@ if(i>j) j++;
	else i++;
}
```
```textile
n
```
(4):
```cpp
x=n; y=0;
while(x>=(y+1)*(y+1)){
	@ y++;
}
```
```textile
\sqrt{n} 向下取整
```
(5):
```cpp
x=91; y=100;
while(y>0){
	@ if(x>100) {x-=10; y--;}
	else x++;
}
```
```textile
要看y在什么时候<=0
11+11+11+...11 共计有100个11，当y=0时退出循环
```
## 9. 假设n为2的乘幂，并且n>2，试求下列算法的时间复杂度及变量count的值（以n的函数形式表示）
```c
int Time(int n){
	int count = 0, x = 2;
	while(x<n/2){
		x *= 2;
		@ count++;
	}
	return count;
}
```
```textile
@ 处的操作运行m次，则有2^(m+1) >= n / 2
两边同时取log2有：m >= log_2^(n) - 2
故O(log_2^n)，count=log_2^n - 2
```
## 11. 已经有实现同一功能的两个算法，其时间复杂度分别为O(2^n)和O(n^10)，假设现实计算机可连续运算的时间为10^7秒，又每秒可执行基本操作（根据这些操作来估算算法时间复杂度）10^5次，试问在此条件下，这两个算法可解问题的规模（即n值得范围）各为多少？哪个算法更适宜？
```textile
2^n = 10^12, n=40
n^10 = 10^12, n=16
```
则对于同样的循环次数n，在这个规模下，第二种算法所花费的代价要大得多。 故这个规模下，第一种算法更适宜。

## 16. 试写一算法，自大至小依次输出顺序读入的三个整数x,y,z的值
> 原书的算法程序有问题，该算法是求最大值的算法。
```c
int max3_1(int x, int y, int z){
	if(x>y){
		if(x>z) return x;
		else return z;
	}else{
		if(y>z) return y;
		else return z;
	}
}
```
上述算法用条件语句可以改写为：
```c
int max3_2(int x, int y, int z){
	return (x > y) ? ((x > z) ? x : z) : ((y > z) ? y > z);
}
```